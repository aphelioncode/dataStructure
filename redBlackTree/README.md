有时候面试官会要求面试者手写红黑树。

这里提供一个java 实现版本

红黑树可以在O(logn)时间复杂度内实现插入、删除和查找。

本质上，红黑树是通过控制树高来维持平衡，
AVL树的任意节点的左右子树高度不超过1
红黑树的任意节点的左右子树高度不超过2倍

红黑树具有以下5点性质，在插入和删除中，维持性质不变。
1. 每个节点要么是红色，要么是黑色
2. 根节点是黑色
3. 叶节点（NIL)是黑色
4. 从根节点到叶节点的路径不存在连续的两个红节点
5. 所有从根节点到叶节点的路径黑色节点数目都相同

其中性质2，3主要是为了方便代码实现
性质4，5维持了红黑树的平衡 -> 任意一条路径的长度不会超过另一条路径的两倍

假设红黑树根节点到叶节点的路径中黑色节点的数目为h（不考虑NIL节点）
则节点数量n最少为2^h-1,即所有节点都是黑色节点。
节点数量n最多为2^2h-1，即所有路径都是红黑相间
即 2^h-1<=n<=2^2h-1
即 1/2 log(n+1)<=h<=log(n+1)
实际树高H最多为2h, h<=H<=2h
可得1/2 log(n+1) <=H<=2 log(n+1)

所以红黑树的树高是O(logn),在插入和删除的调整次数和树高相关，具体实现见代码。
这就保证了红黑树可以在O(logn)时间复杂度内实现插入、删除和查找。
